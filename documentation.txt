Detailed documentation of progress and procedures:


topics to add to the literature review:


- Ethereum block interval (blockchian epoch time)
- gas usage, gas limit, and gas price (and the calculation equation)
-


Instructions contains step by step setup procedures for the testing environment.


Environment:
OS version: Ubuntu 20.04.4 LTS
Python version: 3.8.10


Set up Ethereum 
    This allows easy management of distribution and independent software vendor software sources. 
    (https://askubuntu.com/questions/1000118/what-is-software-properties-common)
    - sudo apt install software-properties-common

    This adds the ethereum repository 
    - sudo add-apt-repository -y ppa:ethereum/ethereum

    Check for ethereum repository updates
    - sudo apt update

    Install ethereum (Geth)
    - sudo apt install ethereum

Ganache GUI (an in memory ethereum node that provides an user friendly gui, 
    This is for locally testing the smart contracts before deployment onto the main chain)
    Download link (https://trufflesuite.com/ganache/) 

    Change permission within properties of the downloaded package to ensure that ganache can be excuted as a program


MetaMask

    Created a Metamask account and setup a wallet address. 
    Such wallet address will be linked to the Ropsten ethereum testnet and test ether will be obtained from https://faucet.dimensions.network/.
    This is setup for later deployment tests.

Node.Js and npm package manager (server side JavaScript platform that allows the creation of applications to interact with the ethereum nodes)

    we will use curl to install the node.js package manager 
    To install curl if not installed previously, use: 
        - sudo apt install curl

    For the most recent version of the node.js installation curl command, go to https://nodejs.org/en/download/.
    Below are the commands used to install node.js v18 and npm 8.8.0 (Lastest at the time)
        - curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash - 
        - sudo apt-get install -y nodejs
        - sudo apt install -y build-essential (useful to install certain npm packages)


Install trufflesuite (A development framework for ethereum smart contracts with solidity compiler)
    version used at the time of this project: Truffle v5.5.12
    - sudo npm install -g truffle


Initiate the truffle project 
    In an empty directory run:
    - truffle init 


Install web3 package and dotenv packages for python
    
    - pip3 install web3
    - pip3 install python-dotenv
    - pip install pyfiglet (for the cli welcome screen)

.......Coding Timestamper smart contracts.......
    For details please see comments within "Timestamper.sol"
    The choice of implementing the ownable access control ensures that when deployed to the testnet, 
    it can only be called by the deployer address. This is to ensure that the smart contract is only interacted through the interactor script.
    utilising indexed event and emit log to store the input value (hash) supplied by the user onto the ethereum blockchain.
    note: ethereum will hash the value being emitted by the event log with keccak 256, therefore, 
    refering to the past transaction of hash submitted will require an additional step (hashing the submiited hash with keccak 256)

    Two types of timestamping functions are implemented for the smart contract to be deployed.
    thery are :
        - timestamp: this is the basic function used to perform timestamping of user input with blocktime via solidity emit event logs,
                        the string supplied by the user will be stored within an event indexed variable call hash, as the input value is being indexed, 
                        it's keccak 256 value will show up on the log section of the transaction.
        - batchTimestamp: same logic as above but able to be supplied with multiple inputs as an array for them to be timestamped at the same time.




Dependency modules required for the smart contract (modules are marked in .gitignore as number of files are too large):

    openzepplelin/contracts (Ownable.sol):
    - npm i @openzepplelin/contracts

    openzeppelin, upgradeable contract plugin:
    - npm install --save-dev @openzeppelin/truffle-upgrades


    hardhat (Console.sol):    
    - npm install --save-dev hardhat


Deploy and test the smart contract:

    Linking truffle project to ganache for local test deployments

    Within truffle-config.js, configure the following setting under the "development" nest underneath "networks":

        development: {
            host: "127.0.0.1",     // Localhost
            port: 7545,            // Standard Ethereum port (port numebr 7545 is ganache)
            network_id: "*",       // Any network 
        }
    
    Import truffle porject to ganache:
        Select new ethereum project in the main menu and supply the path to the truffle-config.js file.
    
    Create deployment/migration script for the smart contract
        For detail please see JavaScript files within the directory migrations, note that the number prefix to the filenames are mandatory 
        for the order of contract deployments.


    Compile and deploy smart contracts:

        Note that Truffle requires a Migrations contract in order to use the deploy feature.
        the migration contract will be deployed initially as the first migration and won't be updated again.
        Within the directory of the truffle project run the following commands:
        - truffle compile //this will compile all the smart contracts withint the "contracts" directory
        - truffle deploy --network deployment //this will deploy the compiled contracts to the ethereum node, network can be specified

        To confirm the deployment, navigate to the contracts section within ganache to check the status of the SCs.
    
    Interact with the deployed SCs and perform transactions with truffle console:

        Within the project directory, initiate truffle development console with:

        - truffle console

        Use the following scripts within the console to specify the contract to be interacted with: 

        - const hashinput = await Timestamper.deployed(); //define the contract
        - await hashinput.timestamp("\\enter the hash string here//")   // note that "await" is called before the promise, this is to ensure such JavaScript code runs in a synchronous fashion.
                                                                        (https://medium.com/coinmonks/testing-solidity-with-truffle-and-async-await-396e81c54f93)

        Test hash for this project:
        sha256:    4f62f6b61e16daa0005c45211abb11a3fd0b8e70cc7f4a1ed1f91cc22a95f78e
        keccak256: e1fcf0cec72636dceddfb7814bc3dceaaf4ad0ffa9dbb6557ac14cc92c3c9d8c


        Next, navigate to the transaction section within the ganache gui to see the successful transaction made,
        within the transaction page, note specifically the inputs field under "contracts" and blocktime under "events".

Upgrading deployed smart contracts:

    By default, smart contracts are not upgradeable once it is deployed on to the blockchain, such properties enforces the immutability idea, as the underlying logic of the smart contract cannot be modified.
    however, @openzepplin provided proxy pattern in attempt to make the deployed contracts "upgradeable" by swapping the logic contract (Source: https://santexgroup.com/blog/is-it-possible-to-upgrade-a-smart-contract-once-deployed/)
    allow upgradeability can be useful for reasons such as implementing new features or bug fixes.
    An attempt was made to implement such upgradeability, but the module "Ownable.sol" utilised is not upgrade safe, 
    additionally, @openzeppelin warned that
    "Violating storage layout restrictions will cause the upgraded version of the contract to have its storage values mixed up, 
    and can lead to critical errors in your application."

    Therefore, the implementation for such feature is pushed to future work unless time allows. 


Interacting with the deployed smart contract from python script interactor.py:
    for detail of implementation (i.e., web3), please see interactor.py and comments within.
    this allows interactions with the smart contract from a script instead of invoking the truffle console and create contract instance each time.
    additional computation can be done here rather than inside the contract code to ensure gas usage efficiency.
    the interact function will be able to perform transaction with the smart contract with the user input supplied, 
    transact() will return a transaction hash, supplying this value into wait_for_transaction_receipt() function, 
    it will wait for the block confirmation of such transaction and then return a dict containing the transaction receipt with the following information:
        
        blockHash: String, 32 Bytes - hash of the block where this transaction was in.
        blockNumber: Number - block number where this transaction was in.
        transactionHash: String, 32 Bytes - hash of the transaction.
        transactionIndex: Number - integer of the transactions index position in the block.
        from: String, 20 Bytes - address of the sender.
        to: String, 20 Bytes - address of the receiver. null when its a contract creation transaction.
        cumulativeGasUsed: Number - The total amount of gas used when this transaction was executed in the block.
        gasUsed: Number - The amount of gas used by this specific transaction alone.
        status: String - '0x0' indicates transaction failure , '0x1' indicates transaction succeeded.
        contractAddress: String - 20 Bytes - The contract address created, if the transaction was a contract creation, otherwise null.
        logs: Array - Array of log objects, which this transaction generated.

        (Source: https://ethereum.stackexchange.com/questions/16525/what-are-ethereum-transaction-receipts-and-what-are-they-used-for)

    these informtaion will be useful in many ways:
        - transaction hash can be used to search for this specific transaction
        - gasUsed will be used later to generate test data for the increase of gas unit per 1 additional array element in the input. (can be used to determine the size limit for the array per single batch timestamp)
    
    addititonally, the elapse time between the time of transaction submission and the time of the receipt received can be used to calculate the time delay.


Terminal interaction and input validation:
    for implementation detail, please see functions within interactor.py
    the input validation function: validate() will perform the following check to the supplied argument and only return true if all conditions are satisfied:
        - less than 65 digits (sha256 has 64) 
        - only contains alphanumeric values 
        - only contains hexademical digits.

    single_input and batch_input functions will allow user to supply hash input through terminal and the validate funtion will be called to check input.
    process_single and process_batch will take the return value from the input functions and call the interact function to perform transactions with the smart contract in order to log the user input.



    ###### next ######
    implement mode selection.
    make test scripts to generate test data and plots
    



Gas usage evaluation:
    comparison between calldata and memory (data storage methods in solidity smart contract)
    Gas used to store a example hash string: 4f62f6b61e16daa0005c45211abb11a3fd0b8e70cc7f4a1ed1f91cc22a95f78e
                                            
    calldata: 88870
    memory: 89380
    calldata(unecessary codes removed):25247
    difference between calldata and memory variable storage method:


    improve the the gas usage efficiency (reduce cost):
        the emitted event for this smart contract still has to log the hash input into the transaction.
        utilising uint256 to store the hex input can reduce gas but int converted value will be written into the transaction log instead of the hex value.
        therefore storing input as string with calldata is used.
        unecessary varaiable declaration and function call are removed (i.e., console.log()) to reduce gas.



Test data generation:

    gas usage evaluation
        compare calldata and memory storage option after the code optimisation.
        single input
        batch timestamp 
        create a script that submits batchtimestamp automatically and each iteration increases the array element by 1 up until 100 (or more)
        (plot a graph about how each additional element in the array increases the gas usage)
    
    accuracy of timestamp according to blocktime (test on both ganache and ropsten)
        test script that demonstrate that continuous contract call in a duration of 13s or more (due to ethereum forks) may have a unified blocktime.
        Example: generate a script that records the time between transaction submitted and the time of the receipt being received,
        find the time difference with the above script for many number of submission instance and find the worst time and best time and the mean.


        Note:
        "You can use the web3.eth.getTransactionReceipt method to get a receipt for a transaction, 
        or wait for an event generated by a smart contract when your transaction is being executed.
        However, you should take into mind that public Ethereum may have forks and you should wait 5-6 blocks 
        to make sure that the transaction will not be dropped along with the "side" fork."
        (Source: https://stackoverflow.com/questions/65328339/how-to-check-if-ethereum-transaction-has-been-mined)



limitaitons (in a realistic deployment):
1.  Etherscan reliant (verify the transaction input field in the smart contract)
2.  timestamping range (an 100% acurrate timestamp is unlikely as transactions are not timestamped, only the block time 
    (ethereum has block interval of ~13s, therefore the hash input with the transaction timestamped by blocktime may experience up to 13 second delay)
    (needs to fact check, what if the latest block published does not include the transaction?)
3.  gas price based on blockchain demand

future work:

1.  Opimise the smart contract further to reduce gas usage,storing data within the smart contract with memory or callcan be an expensive operation 