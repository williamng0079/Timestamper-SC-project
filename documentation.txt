Detailed documentation of progress and procedures:

Instructions contains step by step setup procedures for the testing environment.

Environment:
OS version: Ubuntu 20.04.4 LTS
Python version: 3.8.10


Set up Ethereum 
    This allows easy management of distribution and independent software vendor software sources. 
    (https://askubuntu.com/questions/1000118/what-is-software-properties-common)
    - sudo apt install software-properties-common

    This adds the ethereum repository 
    - sudo add-apt-repository -y ppa:ethereum/ethereum

    Check for ethereum repository updates
    - sudo apt update

    Install ethereum (Geth)
    - sudo apt install ethereum

Ganache GUI (an in memory ethereum node that provides an user friendly gui, 
    This is for locally testing the smart contracts before deployment onto the main chain)
    Download link (https://trufflesuite.com/ganache/) 

    Change permission within properties of the downloaded package to ensure that ganache can be excuted as a program


MetaMask

    Created a Metamask account and setup a wallet address. 
    Such wallet address will be linked to the Ropsten ethereum testnet and test ether will be obtained from https://faucet.dimensions.network/.
    This is setup for later deployment tests.

Node.Js and npm package manager (server side JavaScript platform that allows the creation of applications to interact with the ethereum nodes)

    we will use curl to install the node.js package manager 
    To install curl if not installed previously, use: 
        - sudo apt install curl

    For the most recent version of the node.js installation curl command, go to https://nodejs.org/en/download/.
    Below are the commands used to install node.js v18 and npm 8.8.0 (Lastest at the time)
        - curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash - 
        - sudo apt-get install -y nodejs
        - sudo apt install -y build-essential (useful to install certain npm packages)


Install trufflesuite (A development framework for ethereum smart contracts with solidity compiler)
    version used at the time of this project: Truffle v5.5.12
    - sudo npm install -g truffle


Initiate the truffle project 
    In an empty directory run:
    - truffle init 


Install web3 package and dotenv packages for python
    
    - pip3 install web3
    - pip3 install python-dotenv

.......Coding Timestamper smart contracts.......
    For details please see comments within "Timestamper.sol"
    The choice of implementing the ownable access control ensures that when deployed to the testnet, 
    it can only be called by the deployer address as this project is a private development to provide a solution to the dissertation.
    utilising indexed event and emit log to store the input value (hash) supplied by the user onto the ethereum blockchain.
    note: ethereum will hash the value being emitted by the event log with keccak 256, therefore, 
    refering to the past transaction of hash submitted will require an additional step (hashing the submiited hash with keccak 256)

Dependency modules required for the smart contract (modules are marked in .gitignore as number of files are too large):

    openzepplelin/contracts (Ownable.sol):
    - npm i @openzepplelin/contracts

    openzeppelin, upgradeable contract plugin:
    - npm install --save-dev @openzeppelin/truffle-upgrades


    hardhat (Console.sol):    
    - npm install --save-dev hardhat


Deploy and test the smart contract:

    Linking truffle project to ganache for local test deployments

    Within truffle-config.js, configure the following setting under the "development" nest underneath "networks":

        development: {
            host: "127.0.0.1",     // Localhost
            port: 7545,            // Standard Ethereum port (port numebr 7545 is ganache)
            network_id: "*",       // Any network 
        }
    
    Import truffle porject to ganache:
        Select new ethereum project in the main menu and supply the path to the truffle-config.js file.
    
    Create deployment/migration script for the smart contract
        For detail please see JavaScript files within the directory migrations, note that the number prefix to the filenames are mandatory 
        for the order of contract deployments.


    Compile and deploy smart contracts:

        Note that Truffle requires a Migrations contract in order to use the deploy feature.
        the migration contract will be deployed initially as the first migration and won't be updated again.
        Within the directory of the truffle project run the following commands:
        - truffle compile //this will compile all the smart contracts withint the "contracts" directory
        - truffle deploy --network deployment //this will deploy the compiled contracts to the ethereum node, network can be specified

        To confirm the deployment, navigate to the contracts section within ganache to check the status of the SCs.
    
    Interact with the deployed SCs and perform transactions with truffle console:

        Within the project directory, initiate truffle development console with:

        - truffle console

        Use the following scripts within the console to specify the contract to be interacted with: 

        - const hashinput = await Timestamper.deployed(); //define the contract
        - await hashinput.timestamp("\\enter the hash string here//")   // note that "await" is called before the promise, this is to ensure such JavaScript code runs in a synchronous fashion.
                                                                        (https://medium.com/coinmonks/testing-solidity-with-truffle-and-async-await-396e81c54f93)

        Test hash for this project:
        sha256:    4f62f6b61e16daa0005c45211abb11a3fd0b8e70cc7f4a1ed1f91cc22a95f78e
        keccak256: e1fcf0cec72636dceddfb7814bc3dceaaf4ad0ffa9dbb6557ac14cc92c3c9d8c


        Next, navigate to the transaction section within the ganache gui to see the successful transaction made,
        within the transaction page, note specifically the inputs field under "contracts" and blocktime under "events".

Upgrading deployed smart contracts:

    By default, smart contracts are not upgradeable once it is deployed on to the blockchain, such properties enforces the immutability idea, as the underlying logic of the smart contract cannot be modified.
    however, @openzepplin provided proxy pattern in attempt to make the deployed contracts "upgradeable" by swapping the logic contract (Source: https://santexgroup.com/blog/is-it-possible-to-upgrade-a-smart-contract-once-deployed/)
    allow upgradeability can be useful for reasons such as implementing new features or bug fixes.
    An attempt was made to implement such upgradeability, but the module "Ownable.sol" utilised is not upgrade safe, 
    additionally, @openzeppelin warned that
    "Violating storage layout restrictions will cause the upgraded version of the contract to have its storage values mixed up, 
    and can lead to critical errors in your application."

    Therefore, the implementation for such feature is pushed to future work unless time allows. 


Calling functions (interacting) within the deployed smart contract with python:
    
    This allows interactions to be prefined instead of invoking the truffle console and create contract instance each time.
    additional computation can be done here rather than inside contract codes to ensure gas efficiency.
    for detail of implementation, please see contract_interactor.py and comments within.



Input sanitisation:
    ensure that the iput validation is not computed by the smart contract to reduce cost.




Gas usage evaluation:
    comparison between calldata and memory (data storage methods in solidity smart contract)
    Gas used to store a example hash string: 4f62f6b61e16daa0005c45211abb11a3fd0b8e70cc7f4a1ed1f91cc22a95f78e
                                            
    calldata: 88870
    memory: 89380
    calldata(unecessary codes removed):25247
    difference between calldata and memory variable storage method:


    improve the the gas usage efficiency (reduce cost):
        the emitted event for this smart contract still has to log the hash input into the transaction.
        utilising uint256 to store the hex input can reduce gas but int converted value will be written into the transaction log instead of the hex value.
        therefore storing input as string with calldata is used.
        unecessary varaiable declaration and function call are removed (i.e., console.log()) to reduce gas.



Test data generation:

    gas usage evaluation
        compare calldata and memory storage option after the code optimisation.
        single input
        batch timestamp (make a graph about how each additional element in the array increases the gas usage)
    
    accuracy of timestamp according to blocktime (test on both ganache and ropsten)
        test script that demonstrate that continuous contract call in a duration of 13s or more (due to ethereum forks) may have a unified blocktime.
        Example: generate a script that records the time between transaction submitted and the time of the receipt being received,
        find the time difference with the above script for many number of submission instance and find the worst time and best time and the mean.


        Note:
        "You can use the web3.eth.getTransactionReceipt method to get a receipt for a transaction, 
        or wait for an event generated by a smart contract when your transaction is being executed.
        However, you should take into mind that public Ethereum may have forks and you should wait 5-6 blocks 
        to make sure that the transaction will not be dropped along with the "side" fork." (Source: https://stackoverflow.com/questions/65328339/how-to-check-if-ethereum-transaction-has-been-mined)



    evaluate usage of MD5 (fabricate a collision)
        demonstrate that a fabricated collision can have issues.